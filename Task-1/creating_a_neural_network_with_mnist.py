# -*- coding: utf-8 -*-
"""Creating a neural network with MNIST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18vInGg9aEzDURUJV_9C9fs8CtFijKvgw

# Task 1: Creating a neural network
Create a simple neural network in Python using TensorFlow or any other machine learning
framework. The network must be capable of classifying images from the MNIST dataset.
"""

import tensorflow
tensorflow.__version__

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

"""# Importing the data
In this notebook, we will be working with mnist data set: https://en.wikipedia.org/wiki/MNIST_database

60,000 train images

10,000 test images

image size (28,28)
"""

from tensorflow.keras.datasets import mnist

(x_train, y_train) , (x_test, y_test) = mnist.load_data()

x_train.shape

x_test.shape

type(x_test)

x_train[0]

plt.imshow(x_train[1], cmap='gray')  # Display the array as a grayscale image
plt.show()  # Display the figure

y_train

"""# Convolutional Neural Networks (CNN)"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers

# reshaping
x_train.shape

x_train = x_train.reshape((60000, 28,28,1))
x_train = x_train / 255.0

x_test = x_test.reshape((10000, 28,28,1))
x_test  = x_test / 255.0

x_train.shape

x_test.shape



"""# Creating a CNN model:"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers

# we will be using functional api

def CNN_builder():
    inputs= keras.Input(shape=(28,28,1), name='Input layer')
    x = layers.Conv2D(filters= 32, kernel_size = 3, strides = (1,1) , padding='valid',  activation='relu' ,name="conv_layer_1")(inputs)
    x = layers.MaxPool2D(pool_size=2, name="pooling_1")(x)
    x = layers.Conv2D(filters= 64, kernel_size = 3, activation='relu', name="conv_layer_2")(x)
    x = layers.MaxPool2D(pool_size=2, name="pooling_2")(x)
    x = layers.Conv2D(filters= 128, kernel_size = 3, activation='relu', name="conv_layer_3")(x)
    x = layers.Flatten(name="flattening_layer")(x)
    x = layers.Dense(units= 64, activation='relu')(x)
    outputs = layers.Dense(units= 10, activation='softmax', name='output_layer')(x)

    model = keras.Model(inputs= inputs , outputs=outputs, name='my_first_CNN_model')

    model.compile(optimizer='rmsprop',
                  loss='sparse_categorical_crossentropy', # Multi-class classification (orders, no one-hot encoding)
                  metrics=['accuracy'])

    return model

model = CNN_builder()
model.summary()

# params
1*(3*3)*32 + 32

32*(3*3)*64+64

64*(3*3)*128+128

3*3*128

1152*64+64

64*10+10

# for example, the output shape of conv_layer 1 is (None, 26,26, 32)
np.floor(((28+0-3)/1)+1)

"""# Fit this Model"""

from tensorflow.keras.callbacks import  ModelCheckpoint
modelcheckpoint  = ModelCheckpoint(filepath="first_CNN.h5",save_best_only=True, monitor="val_loss")

history = model.fit(x=x_train, y=y_train,
          validation_data=(x_test, y_test),
          epochs=10, batch_size=64, callbacks=[modelcheckpoint])

60000/64

test_model = keras.models.load_model("first_CNN.h5")
test_model.evaluate(x_test, y_test)

"""As we can see, this simple CNN performs really well in the test set with +99% accuracy.

# Model evaluation
"""

model.metrics_names

metrics = pd.DataFrame(history.history)

metrics.head()

metrics[['accuracy','val_accuracy']].plot()
plt.show()

metrics[['loss','val_loss']].plot()
plt.show()

predictions_prob = model.predict(x_test)
predictions_prob[0]

predictions_prob.shape

y_test[0]

"""let's generate prediction classes:



*   For binary classification, np.where(y_pred > threshold, 1,0)
*   For multiclass classification, np.argmax(predictions, axis=1)



"""

predictions = np.argmax(predictions_prob, axis=1)
predictions[0:5]

from sklearn.metrics import classification_report,confusion_matrix

print(classification_report(y_test,predictions))

confusion_matrix(y_test,predictions)

import seaborn as sns
plt.figure(figsize=(10,6))
sns.heatmap(confusion_matrix(y_test,predictions),annot=True)
plt.show()

y_test!=predictions

misclassified_images = [i for i, x in enumerate(y_test!=predictions) if x==True]
misclassified_images[:9]

x_test[0].shape

plt.imshow(x_test[0].reshape(28,28))

for a, b in enumerate(misclassified_images[:9]):
  print (a, b)

plt.figure(figsize=(10,10))

actuals = []
for i , number in enumerate(misclassified_images[:9]):
  ax = plt.subplot(3,3,i+1)
  plt.imshow(x_test[number].reshape(28,28))
  actuals.append(y_test[number])
plt.show()

actuals

predictions[misclassified_images[:9]]